<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Radius Docs – Concept</title>
    <link>https://docs.radapp.io/categories/concept/</link>
    <description>Recent content in Concept on Radius Docs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	  <atom:link href="https://docs.radapp.io/categories/concept/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Concepts: Concept: Why Radius?</title>
      <link>https://docs.radapp.io/concepts/why-radius-concept/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.radapp.io/concepts/why-radius-concept/</guid>
      <description>
        
        
        &lt;h2 id=&#34;our-starting-point&#34;&gt;Our starting point&lt;/h2&gt;
&lt;p&gt;We started Radius to simplify and improve upon tools application developers use to deploy and manage applications. Our initial goal was just to create a platform for deployment that developers would love but, as we talked to more cloud customers, we realized almost every enterprise is creating a custom internal developer platform to standardize the way they deploy and manage cloud-native applications&lt;/p&gt;
&lt;p&gt;Most enterprises are not dev-tools experts and as a result they struggle with the cost and complexity of building a home-grown solution. If we could provide an open-source solution that solved these problems for enterprises we could have a big impact.&lt;/p&gt;
&lt;p&gt;A few common problems rose to the top:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Applications are more than just Kubernetes:&lt;/strong&gt; standardizing on Kubernetes has been a successful strategy for most enterprises, but applications developers are tasked with managing applications on Kubernetes along with multiple resources in the cloud. Integrating Kubernetes with cloud services has added additional complexity while making compliance with best-practices almost a full-time job.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Developers, platform engineers, and  IT operators need to collaborate:&lt;/strong&gt; to manage the complexity of the cloud, enterprises have specialized disciplines like sec-ops, fin-ops, and cloud centers of excellence. Application developers need to interface with all of these roles, and the tools they use should aid, not impede collaboration.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Applications lack an industry-wide definition:&lt;/strong&gt; the IT operators, SREs and other specialists that support an application usually lack context about the architecture. Application developers lack context about the underlying cloud infrastructure. As application developers and IT operators collaborate they need a common understanding and visualization of what an application &lt;strong&gt;is&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, we started Radius to address these concerns and provide &lt;strong&gt;our&lt;/strong&gt; opinions about how application management should work in today&amp;rsquo;s complex cloud-native landscape. Along the way we came up with the concept of &lt;strong&gt;Appi-ness&lt;/strong&gt;: the feeling of satisfaction one has when the application is at the center of every workflow.&lt;/p&gt;
&lt;h2 id=&#34;applications-are-more-than-just-kubernetes&#34;&gt;Applications are more than just Kubernetes&lt;/h2&gt;
&lt;p&gt;The modern cloud-native application includes much more than Kubernetes. Applications use databases, message queues, identity systems, SaaS accounts, and observability platforms. However, most of the tools that are available for developers are focused on the Kubernetes basics of compute, storage, and networking.&lt;/p&gt;
&lt;p&gt;Our philosophy is to be inclusive when considering what is &lt;em&gt;part of the application&lt;/em&gt;. Developers can use cloud resources directly or use Recipes configured by operators for on-demand provisioning of infrastructure. We automate best-practices like IAM/identity assignment, permissions management, diagnostics, and networking configuration based on the application architecture and developer intent. We hope that features like Connections feel like magic when its easy to wire up your dependencies.  IT operators control the templates and credentials used to interact with the cloud ensuring that provisioning is done in a supported way.&lt;/p&gt;
&lt;h2 id=&#34;developers-and-platform-engineers-need-to-collaborate&#34;&gt;Developers and platform engineers need to collaborate&lt;/h2&gt;
&lt;p&gt;Enterprises are creating specialized roles and initiatives to improve their speed, efficiency, and security when adopting the cloud. Platform engineering is an emerging discipline that&amp;rsquo;s combining a product mindset with learnings from DevOps and DevSecOps teams to create internal development platforms. When successful, platform engineers deliver a set of tools that provide sufficient automation, tracking, governance, and observability that guide development teams naturally fall “into the pit of success.” Often these endeavors can come up a little short, looking like a set of repository templates, cloud resource templates, and a software catalog for application developers to use. Unfortunately, the tools and assets that are frequently used don&amp;rsquo;t encourage collaboration between developers and the platform engineers supporting those developers. Platform engineering is new as a discipline, and the patterns that will make enterprises successful long-term are still emerging.&lt;/p&gt;
&lt;p&gt;Radius provides concepts like Environments and Recipes that support a separation of concerns. Platform engineers can create repository templates with CI/CD pipelines and starter code for deployment. IT operators can deploy and govern the Environments where those pipelines deploy applications. Cloud and security experts can provide the Recipes used to create and update cloud resources. Developers are only responsible for describing the requirements and architecture of the application, understanding which environments to use, and choosing dependencies from the supported set of Recipes.&lt;/p&gt;
&lt;h2 id=&#34;applications-need-an-industry-standard-definition&#34;&gt;Applications need an industry-standard definition&lt;/h2&gt;
&lt;p&gt;The myriad of operational roles that support applications in production rarely have the full picture of how the application is architected or a complete picture of the infrastructure resources that are in use. It can be difficult for an organization to understand the impact of an outage or what is causing high consumption and high cost for a cloud resource without a holistic understanding of the application. Unless developers are creating the cloud resources themselves, its hard for them to understand the real infrastructure at work. Teams are adopting software catalogs to help address these problems but there is always drift between the catalog and the source of truth.&lt;/p&gt;
&lt;p&gt;We wanted to do better by building a flexible and customizable picture of what an application &lt;em&gt;is&lt;/em&gt;. To do this we capture the developer&amp;rsquo;s understanding of the application during deployment and combine that picture with the cloud resources and Recipes used to provision the infrastructure. This data is used to build the Application Graph, a new kind of software catalog that describes the application&amp;rsquo;s architecture, communication patterns, and dependencies as a shared view for the whole organization.&lt;/p&gt;
&lt;p&gt;We hope that this holistic way of thinking about applications becomes the standard and that together with the rest of the cloud-native ecosystem we can build a set of tools that promote &lt;strong&gt;Appi-ness&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;what-were-not-rethinking&#34;&gt;What we&amp;rsquo;re not rethinking&lt;/h2&gt;
&lt;p&gt;Many practices and technologies in cloud-native development are a success and don&amp;rsquo;t need to be re-thought.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Radius makes is easy for application developers to adopt because it supports your existing containerized code, Dockerfiles, and Helm charts.&lt;/li&gt;
&lt;li&gt;We believe that &lt;a href=&#34;https://12factor.net/&#34;&gt;twelve-factor&lt;/a&gt; is still a great set of ideas and so any twelve-factor style application should be easy to use with Radius.&lt;/li&gt;
&lt;li&gt;We like infrastructure-as-code as for its repeatability and use it for both Recipes and application descriptions.&lt;/li&gt;
&lt;li&gt;There are plenty of great CI/CD systems, application delivery pipelines, and Gitops systems out there and Radius can work with any of them.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;open-source-from-the-start&#34;&gt;Open-source from the start&lt;/h2&gt;
&lt;p&gt;We planned for Radius to be open-source from the start because we want to reach as many developers, organizations, and ecosystem partners as we can. Open-source can mean different things to different people. For Radius, open-source means that our source code is publicly available under an OSI-approved permissive license. It also means that the Radius project uses an neutral and open governance model to continue the evolution of Radius as a multi-cloud technology going forward. Anyone should be able to contribute to Radius, extend the platform, self-host Radius for internal use, or use it to build a business hosting other people&amp;rsquo;s applications.&lt;/p&gt;
&lt;p&gt;We know from our conversations with enterprises that customization, extensibility, and a large ecosystem are key. Every organization is unique and will make different policy, workflow, and technology choices. Every large organization has critical internal technologies. Extensibility is the way to put those internal technologies on even-footing with the cloud. A large ecosystem of partners and integrations enables everyone to keep using the technologies they are already committed to. By participating in open-source, users have a direct channel to propose changes, give feedback, add features, or customize the version of Radius they use. Our commitment to open-source and neutral, open governance means any technology vendor can join the ecosystem and benefit from the level playing-field that&amp;rsquo;s being created.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Concepts: Concept: Open-source and multi-cloud</title>
      <link>https://docs.radapp.io/concepts/multi-cloud-concept/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.radapp.io/concepts/multi-cloud-concept/</guid>
      <description>
        
        
        &lt;h2 id=&#34;organizations-are-increasingly-multi-cloud&#34;&gt;Organizations are increasingly multi-cloud&lt;/h2&gt;
&lt;p&gt;Radius is designed to meet developers, and the platform engineers that support them, where they are, integrating with existing best practices while providing new benefits through features like the Radius Application Graph and Radius Environments and Recipes. We talked to a lot of organizations about their cloud usage, and learned that they were either using multiple cloud providers or were going to use multiple cloud providers. In short, multi-cloud is a trend that is accelerating in popularity.&lt;/p&gt;
&lt;p&gt;What does multi-cloud really mean? Throughout the design phase of Radius, we&amp;rsquo;ve have many conversations with large enterprises about their usage of the cloud, and in particular about their usage of multiple clouds. We were curious about why enterprises use multiple clouds and what problems they need help solving. In talking with these enterprises and with cloud native software vendors we found three types of multi-cloud use:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Multi-cloud enterprise: these enterprises deployed some applications to one cloud provider and other applications to another cloud provider.&lt;/li&gt;
&lt;li&gt;Cloud-agnostic applications: these enterprises deploy the same application to different cloud providers.&lt;/li&gt;
&lt;li&gt;Multi-cloud application: these enterprises have a single application that is distributed across multiple clouds.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The third case, a single application that is running across multiple clouds, was incredibly rare. Enterprises that had experimented with multi-cloud applications cited almost insurmountable challenges with operations, security, and performance management. While Radius can help with these kinds of applications, supporting these kinds of applications was not a design goal for Radius.&lt;/p&gt;
&lt;p&gt;Radius is designed to meet the first two types of multi-cloud use.&lt;/p&gt;
&lt;h3 id=&#34;multi-cloud-enterprise&#34;&gt;Multi-cloud enterprise&lt;/h3&gt;
&lt;p&gt;The multi-cloud enterprise case was the most common case we encountered. Some enterprises explained that they were multi-cloud due to decentralized decision making, acquisitions, or inertia. For example, some enterprises let individual engineering teams decide which cloud worked best for the type of application they were building. These teams would select a cloud provider for a variety of reasons, such as prior experience with a cloud provider, unique cloud provider features, or the way a particular cloud provider integrated with other tools or practices used by the team.&lt;/p&gt;
&lt;p&gt;Some enterprises explained that they were multi-cloud through acquisitions. Their new parent company might have selected a particular cloud provider that is different than their choice. For many customers we spoke with there was little to no requirement to migrate their existing applications from one cloud provider to another cloud provider.&lt;/p&gt;
&lt;p&gt;Finally, some enterprises explained that they were multi-cloud due to inertia. They had started with one cloud provider, but later, switched to using a different provider as their primary choice for new applications. Like the acquisition case above, there was no requirement to move existing applications to the new cloud provider.&lt;/p&gt;
&lt;p&gt;Radius was designed with these enterprises in mind. Enterprises can &amp;ldquo;radify&amp;rdquo; their applications regardless of cloud provider, enabling these enterprises to use Radius regardless of whether or not the application is using a particular public cloud provider or a private cloud operated by the enterprise itself. Radius applications can use cloud vendor specific technologies, like Amazon&amp;rsquo;s DynamoDB or Azure&amp;rsquo;s Cosmos DB, or they can use open source technologies like Redis.&lt;/p&gt;
&lt;h3 id=&#34;cloud-agnostic-applications&#34;&gt;Cloud-agnostic applications&lt;/h3&gt;
&lt;p&gt;There were some enterprises that ran the same application in multiple clouds. Often these enterprises had business requirements that required them to use multiple cloud providers. For example, some financial services enterprises had to host their application and any data associated with the application in a particular country or geographic region. The enterprise would need their application to be deployable to whichever cloud provider was available in a specific country or region.&lt;/p&gt;
&lt;p&gt;Radius was designed to support this specific use case from the start. We wanted to make it possible for IT teams, platform engineering teams, or cloud center of excellence teams to make decisions about which cloud provider an application would use. We wanted them to be able to make that decision without having an impact on their developers and the application logic those developers were writing.&lt;/p&gt;
&lt;p&gt;Radius supports cloud-agnostic applications in two ways. First, enterprises can use open source technologies in their applications. For example, developers that need a cache might use a Redis cache in their application. The platform engineering team would build Radius Recipes that, depending on the cloud provider, would use a different underlying Redis compatible service. This might mean using Azure Cache for Redis when deploying to Azure or Amazon ElastiCache for Redis on AWS. The developer&amp;rsquo;s application logic and deployment assets like Helm charts should be the same, regardless of which cloud they&amp;rsquo;re using.&lt;/p&gt;
&lt;p&gt;The second way Radius supports cloud-agnostic applications is with &lt;a href=&#34;https://dapr.io&#34;&gt;Dapr, the Distributed Application Runtime&lt;/a&gt;. Dapr provides developers with APIs that abstract away the complexity of common challenges developers encounter regularly when building cloud native applications. These API building blocks abstract away services that provide state management, secrets management, or publish and subscribe systems. Developers can write to Dapr and platform engineering teams can use Radius to provide the underlying infrastructure for these Dapr based applications. For example, a Dapr application that&amp;rsquo;s persisting state could use Azure Blob Storage or Amazon DynamoDB as the underlying state store depending on which cloud provider was used to host the application.&lt;/p&gt;
&lt;p&gt;Radius was designed from the start to support enterprises in implementing their multi-cloud strategy. Enterprises can use cloud vendor technologies, like DynamoDB, or they can build on open source technologies like Redis and Dapr.&lt;/p&gt;
&lt;h2 id=&#34;open-source&#34;&gt;Open-source&lt;/h2&gt;
&lt;p&gt;Many enterprises use open-source technologies as a way of &lt;em&gt;achieving&lt;/em&gt; their multi-cloud strategy. Kubernetes adoption is a great example of this trend. Customers building on Kubernetes can leverage their Kubernetes experience, tools, and practices with any cloud provider and they&amp;rsquo;re confident Kubernetes, with it&amp;rsquo;s broad community, will continue to be a multi-cloud technology.&lt;/p&gt;
&lt;p&gt;Radius was designed to be an open-source project from the start as part of the way Radius would support enterprise multi-cloud strategies. Open-source can mean different things to different people. For Radius, open-source means that our source code is publicly available under an OSI-approved permissive license. It also means that the Radius project uses an neutral and open governance model to continue the evolution of Radius as a multi-cloud technology going forward. Anyone should be able to contribute to Radius, extend the platform, self-host Radius for internal use, or use it to build a business hosting other people&amp;rsquo;s applications.&lt;/p&gt;
&lt;p&gt;The Radius team has worked with the Cloud Native Computing Foundation (CNCF) to bring Radius into the CNCF as a new CNCF project. The Radius team is optimistic that Radius will be a success, both in helping enterprises achieve their multi-cloud strategies as well as in bringing powerful concepts, like Environments, Recipes, and the Application Graph, to the broader cloud native community.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Concepts: Radius API</title>
      <link>https://docs.radapp.io/concepts/api-concept/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.radapp.io/concepts/api-concept/</guid>
      <description>
        
        
        &lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;Radius provides an HTTP-based API and supporting tools that can deploy and manage cloud-native applications as well as on-premises or cloud resources. The server-side API components are also sometimes called a control-plane. The Radius API can be hosted inside a Kubernetes cluster or as a standalone set of processes or containers. Tools that are used with Radius (like the &lt;code&gt;rad&lt;/code&gt; CLI) communicate with the API.&lt;/p&gt;
&lt;p&gt;This page serves as documentation about the overall API design of Radius to help educate contributors to the project or any user who wants a deeper understanding of the system and its capabilities.&lt;/p&gt;
&lt;h2 id=&#34;resource-management-terminology&#34;&gt;Resource management terminology&lt;/h2&gt;
&lt;p&gt;Before diving in to the details of the API, it is helpful to understand the terms &lt;strong&gt;resource&lt;/strong&gt;, &lt;strong&gt;resource manager&lt;/strong&gt;, and &lt;strong&gt;resource provider&lt;/strong&gt;. Imagine a typical cloud service like a virtual machine. An API for working with virtual machines would include operations like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Creating new virtual machines&lt;/li&gt;
&lt;li&gt;Reading the configuration of a virtual machine&lt;/li&gt;
&lt;li&gt;Updating the configuration of a virtual machine&lt;/li&gt;
&lt;li&gt;Deleting existing virtual machines&lt;/li&gt;
&lt;li&gt;Listing all virtual machines in a cloud account&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the example provided, the virtual machine is the &lt;strong&gt;resource&lt;/strong&gt; and the API providing the management operations for virtual machines listed above is the &lt;strong&gt;resource provider&lt;/strong&gt;. These operations are often referred to as &lt;strong&gt;CRUDL&lt;/strong&gt; (Create, Read, Update, Delete, List) and represent the standard set of operations that most &lt;strong&gt;resource provider&lt;/strong&gt; provide. The overall system including authentication, authorization, routing, and other concerns is called a &lt;strong&gt;resource manager&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Resource providers sometimes provide operations in addition to the CRUDL operations that are specific to the type of resource. For a virtual machine, a resource provider might provide additional operations like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rebooting a virtual machine&lt;/li&gt;
&lt;li&gt;Restoring a virtual machine from backup&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As a result the set of operations is sometimes written as &lt;strong&gt;CRUDL+&lt;/strong&gt;, meaning that a resource provider must implement the &lt;strong&gt;CRUDL&lt;/strong&gt; operations at a minimum and sometimes more.&lt;/p&gt;
&lt;p&gt;Resources have a type (in the programming sense) and a means of being identified (name or id). For example an AWS virtual machine&amp;rsquo;s type would be &lt;code&gt;AWS::EC2::Instance&lt;/code&gt; and might have a generated name like &lt;code&gt;i-0123456789abcdef&lt;/code&gt;. The name must be provided to operations like Update so that the resource provider can identify which resource to update. The name and type can also be combined with additional context to form a unique identifier. For example on AWS the virtual machine name would be combined with the user&amp;rsquo;s account id and the selected region to form a unique identifier called an &lt;a href=&#34;https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html&#34;&gt;ARN&lt;/a&gt;. These identifiers are useful because they provide a universal way to identify which resource is being named.&lt;/p&gt;
&lt;p&gt;A resource could be anything that&amp;rsquo;s useful to manage through an API. For example, a resource could be an on-premises networking configuration, a 3rd party SaaS account, a Kubernetes &lt;code&gt;Pod&lt;/code&gt;, or a value stored in a cloud secret store. Resources with CRUDL+ operations, types, and universal identifiers are the central concepts in Radius&amp;rsquo; API because they are a tested approach for deployment and management of software systems.&lt;/p&gt;
&lt;h2 id=&#34;principles-for-the-radius-api&#34;&gt;Principles for the Radius API&lt;/h2&gt;
&lt;p&gt;Radius provides a general resource manager that can manage cloud or on-premises resources as well as opinionated support cloud-native application concerns like containers and databases. Such an API needs to be powerful, flexible, and extensible enough to communicate with a variety of existing systems that were created by different organizations.&lt;/p&gt;
&lt;p&gt;The design of the Radius API incorporates the following principles:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Universal addressing: every resource has a unique identifier called a resource id.&lt;/li&gt;
&lt;li&gt;CRUDL+ lifecycle: resources their functionality through a common set of HTTP contracts in a consistent way.&lt;/li&gt;
&lt;li&gt;Federation based on metadata: rather that duplicate the functionality of existing resource managers, Radius delegates functionality to external APIs and is powered by the metadata of those APIs.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The rest of this page will illustrate these principles further and provide examples.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;💡 Additional Info&lt;/h4&gt;

    The overall design of the Radius API is based on the Azure Resource Manager API (ARM). Radius generalizes the design of ARM, removes proprietary Azure concepts, and extends the ARM contract to support the conventions of other resource managers like Kubernetes or AWS Cloud-Control. It is the goal of the Radius project that the Radius API can serve as a truly universal API for resource management.

&lt;/div&gt;

&lt;h2 id=&#34;resource-ids&#34;&gt;Resource ids&lt;/h2&gt;
&lt;p&gt;Each resource in Radius has a unique identifier called a resource id. Resource ids have a common structure that allows resources to reference one-another. Resource ids also map directly to the URLs used for a resource&amp;rsquo;s lifecycle operations which is convenient for navigating the API.&lt;/p&gt;
&lt;p&gt;The common structure of a resource id is the following:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{rootScope}/{resourceNamespace}/{resourceType}/{resourceName}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;root-scope&#34;&gt;Root scope&lt;/h3&gt;
&lt;p&gt;A hierarchical set of key-value pairs that identify the original of the resource. Root scopes answer questions like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&amp;ldquo;What cloud is this resource from?&amp;rdquo;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;ldquo;What cloud account contains this resource?&amp;rdquo;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;ldquo;What Kubernetes cluster is running this Pod?&amp;rdquo;&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;resource-namespace-and-resource-type&#34;&gt;Resource namespace and resource type&lt;/h3&gt;
&lt;p&gt;The namespace and type of a resource. These are defined together because resource types are usually two segments - a vendor namespace and a type name.&lt;/p&gt;
&lt;h3 id=&#34;resource-name&#34;&gt;Resource name&lt;/h3&gt;
&lt;p&gt;The name of the resource.&lt;/p&gt;
&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;
&lt;p&gt;The following tables shows some examples of resource ids from different resource managers.&lt;/p&gt;
&lt;h4 id=&#34;resource-manager-radius&#34;&gt;Resource manager: Radius&lt;/h4&gt;
&lt;p&gt;This example shows a Radius Application named &lt;code&gt;my-app&lt;/code&gt; in the &lt;code&gt;my-group&lt;/code&gt; resource group, running on the local cluster:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Key&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Root scope&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/planes/radius/local/resourceGroups/my-group&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Namespace/Type&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Applications.Core/applications&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Name&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;my-app&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Resource id&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/planes/radius/local/resourceGroups/my-group/Applications.Core/applications/my-app&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;resource-manager-aws&#34;&gt;Resource manager: AWS&lt;/h4&gt;
&lt;p&gt;This example shows an AWS Kinesis Stream named &lt;code&gt;my-stream&lt;/code&gt; in the &lt;code&gt;0123456789&lt;/code&gt; account, running in the &lt;code&gt;us-west-2&lt;/code&gt; region:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Key&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Root scope&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/planes/aws/aws/accounts/01234556789/regions/us-west-2&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Namespace/Type&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;AWS.Kinesis/Stream&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Name&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;my-stream&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Resource id&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/planes/aws/aws/accounts/01234556789/regions/us-west-2/AWS.Kinesis/Stream/my-stream&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;resource-manager-azure&#34;&gt;Resource manager: Azure&lt;/h4&gt;
&lt;p&gt;This example shows an Azure Storage Account named &lt;code&gt;myaccount&lt;/code&gt; in the &lt;code&gt;00000000-0000-0000-0000-000000000000&lt;/code&gt; subscription and &lt;code&gt;my-group&lt;/code&gt; Azure resource group:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Key&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Root scope&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/planes/azure/azurecloud/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/my-group&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Namespace/Type&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Microsoft.Storage/storageAccounts&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Name&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;myaccount&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Resource id&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/planes/azure/azurecloud/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/my-group/Microsoft.Storage/storageAccounts/myaccount&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;resource-lifecycle&#34;&gt;Resource lifecycle&lt;/h2&gt;
&lt;p&gt;The lifecycle of a resource is modeled using the HTTP methods that best match each lifecycle operation. Some operations like List do not provide a resource name because they operate on a collection of resources, however most do. Where possible, operations are idempotent, meaning that performing the same operation many times will produce the same result.&lt;/p&gt;
&lt;p&gt;This section includes an example based on the Radius &lt;code&gt;Applications.Core/applications&lt;/code&gt; type which represents a cloud-native application.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operation&lt;/th&gt;
&lt;th&gt;HTTP Method&lt;/th&gt;
&lt;th&gt;URL&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;List&lt;/td&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{rootScope}/Applications.Core/applications&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Read&lt;/td&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{rootScope}/Applications.Core/applictions/my-app&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Create/Update&lt;/td&gt;
&lt;td&gt;PUT&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{rootScope}/Applications.Core/applictions/my-app&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Delete&lt;/td&gt;
&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{rootScope}/Applications.Core/applictions/my-app&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The example above demonstrates the CRUDL lifecycle APIs of a resource, all resource types provided by Radius follow this pattern.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;🚧🚧🚧 Under construction 🚧🚧🚧&lt;/h4&gt;

    We&amp;rsquo;re working on providing a detailed protocol reference for the overall UCP protocol.

&lt;/div&gt;

&lt;p&gt;The &lt;a href=&#34;https://docs.radapp.io/reference/resource-schema/&#34;&gt;API Reference&lt;/a&gt; provides a reference to Radius&amp;rsquo; APIs.&lt;/p&gt;
&lt;h2 id=&#34;resource-structure&#34;&gt;Resource structure&lt;/h2&gt;
&lt;p&gt;The JSON body payloads in Radius follow a regular structure to enable clients to work with many resource types in a consistent way. Top-level fields in the JSON payload are reserved for protocol use and must have consistent definitions across resources. The &lt;code&gt;properties&lt;/code&gt; property is reserved for the the resource type to specify its configuration and current state.&lt;/p&gt;
&lt;p&gt;This section includes an example based on the Radius &lt;code&gt;Applications.Core/environments&lt;/code&gt; type which represents a cloud-native deployment environment.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;id&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/planes/radius/local/resourcegroups/default/providers/Applications.Core/environments/default&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;global&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;default&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;compute&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;kind&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;kubernetes&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;namespace&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;default&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;provisioningState&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Succeeded&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;systemData&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;createdAt&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0001-01-01T00:00:00Z&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;createdBy&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;createdByType&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;lastModifiedAt&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0001-01-01T00:00:00Z&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;lastModifiedBy&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;lastModifiedByType&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;tags&amp;#34;&lt;/span&gt;: {},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Applications.Core/environments&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;🚧🚧🚧 Under construction 🚧🚧🚧&lt;/h4&gt;

    We&amp;rsquo;re working on providing a detailed protocol reference for the overall UCP protocol.

&lt;/div&gt;

&lt;h2 id=&#34;versioning&#34;&gt;Versioning&lt;/h2&gt;
&lt;p&gt;All APIs provided by Radius are versioned using the &lt;code&gt;api-version&lt;/code&gt; query-string parameter. API versioning allows clients to request a precise version they desire, and remain compatible as behaviors and APIs change over time.&lt;/p&gt;
&lt;h2 id=&#34;federation&#34;&gt;Federation&lt;/h2&gt;
&lt;p&gt;The API functionality provided by Radius for external systems like AWS or Azure relies on API federation. As a principle, Radius avoids storing data from external systems where possible. This avoids data-synchronization problems while also minimizing resource utilization.&lt;/p&gt;
&lt;p&gt;For example, the Radius API to list all AWS Kinesis Streams will perform the following tasks to satisfy the request:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Parse the resource id from the request URL to determine the AWS account id and region.&lt;/li&gt;
&lt;li&gt;Authenticate with AWS for the specified account.&lt;/li&gt;
&lt;li&gt;Make a request to AWS Cloud-Control to list the Kinesis Streams.&lt;/li&gt;
&lt;li&gt;Adapt the data retrieved from AWS to match the Radius API structure.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;p&gt;ARM/Azure:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/microsoft/api-guidelines&#34;&gt;Microsoft REST API Guidelines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md&#34;&gt;Azure REST API Guidelines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/rest/api/azure/&#34;&gt;Azure REST API Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AWS:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/cloudcontrolapi/&#34;&gt;AWS Cloud-Control&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html&#34;&gt;AWS ARN Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Radius:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.radapp.io/reference/resource-schema/&#34;&gt;API Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Concepts: Radius architecture</title>
      <link>https://docs.radapp.io/concepts/architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.radapp.io/concepts/architecture/</guid>
      <description>
        
        
        &lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;Radius provides an HTTP-based API and supporting tools that can deploy and manage cloud-native applications as well as on-premises or cloud resources. The server-side API components are also sometimes called a control-plane. The Radius API can be hosted inside a Kubernetes cluster or as a standalone set of processes or containers. Tools that are used with Radius (like the &lt;code&gt;rad&lt;/code&gt; CLI) communicate with the API.&lt;/p&gt;
&lt;p&gt;This page serves as documentation about the overall architecture of Radius to help educate contributors to the project or any user who wants a deeper understanding of the system and its capabilities.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Prerequisite:&lt;/strong&gt; Read the &lt;a href=&#34;https://docs.radapp.io/concepts/api-concept/&#34;&gt;API docs&lt;/a&gt; to understand the terminology and structure of the Radius API.&lt;/p&gt;
&lt;h2 id=&#34;design-motivations-for-radius&#34;&gt;Design motivations for Radius&lt;/h2&gt;
&lt;p&gt;The design of the Radius API is based on the team&amp;rsquo;s collected experience building and running hyper-scale cloud resource-management systems. Radius uses proven designs that provide extensibility, multi-tenancy, reliability, and scalability at the level of the world&amp;rsquo;s largest clouds. While Radius used with Kubernetes, the core of Radius is intentionally decoupled from Kubernetes so that Radius can be hosted in any scenario and at any scale.&lt;/p&gt;
&lt;h2 id=&#34;understanding-the-overall-architecture&#34;&gt;Understanding the overall architecture&lt;/h2&gt;
&lt;p&gt;The overall architecture of Radius has three parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A general resource management API.&lt;/li&gt;
&lt;li&gt;Resource providers for cloud-native applications.&lt;/li&gt;
&lt;li&gt;Tools (&lt;code&gt;rad&lt;/code&gt; CLI, Bicep) for deploying and managing applications using the API.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This section will provide a summary of each of these components, as well as examples how common workflows fit together.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;🚧🚧🚧 Under construction 🚧🚧🚧&lt;/h4&gt;

    We&amp;rsquo;re working on adding a diagram to illustrate these points.

&lt;/div&gt;

&lt;h3 id=&#34;ucp-a-general-resource-management-api&#34;&gt;UCP: a general resource management API&lt;/h3&gt;
&lt;p&gt;The Radius API uses a centralized hub-and-spoke architecture. This API provides a single entry-point for authentication, authorization, routing, and other quality-of-service or correctness concerns. All HTTP traffic into the Radius API comes through this central point so that it can be validated before being routed to the appropriate resource provider microservice.&lt;/p&gt;
&lt;p&gt;The service that performs this central functionality in Radius is called the Universal Control-Plane (UCP). UCP receives all inbound HTTP traffic to the Radius API and either serves the response itself or routes the request to a resource provider. UCP is also the central point for extensibility; each resource provider is registered centrally so that UCP knows where to send requests for that resource type.&lt;/p&gt;
&lt;p&gt;UCP contains functionality for federating with separate resource managers as well as its resource providers. For example UCP can route requests to Azure or AWS to manage resources on those cloud systems.&lt;/p&gt;
&lt;p&gt;UCP is a scalable REST API that can function either with a single global shard or using regional sharding. UCP is based on the design principles of the Azure Resource Manager (ARM) control-plane but generalizes to work across multiple clouds and systems. The UCP codebase is fully open-source and was created from scratch as part of the Radius project. UCP is written in Go.&lt;/p&gt;
&lt;p&gt;UCP provides routing and federation with internal and external services:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The management of resources built-in to Radius (such as &lt;code&gt;Applications.Core/containers&lt;/code&gt;) is delegated to the appropriate resource provider.&lt;/li&gt;
&lt;li&gt;The management of cloud resources external to Radius (such as an AWS S3 Bucket, or Azure CosmosDB database) is federated to an external cloud-provider API.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;resource-providers-built-into-radius&#34;&gt;Resource providers built into Radius&lt;/h3&gt;
&lt;p&gt;The role of resource provider in the overall system is to perform the CRUDL+ operations associated with a one or more resource types. Resource providers only accept traffic from UCP and so can assume that any requests they receive are authorized. Each resource provider and the set of resource types it handles must be registered with UCP.&lt;/p&gt;
&lt;p&gt;Like UCP, each resource provider is a scalable REST API that can be deployed as a single global shard or sharded by region.&lt;/p&gt;
&lt;p&gt;Radius provides the following resource providers in the default installation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Applications.Core&lt;/strong&gt;: &lt;em&gt;Core&lt;/em&gt; resources of an application, including the application itself, containers, gateways, and routes.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Applications.Dapr&lt;/strong&gt;: Integration with the &lt;a href=&#34;https://dapr.io/&#34;&gt;Dapr&lt;/a&gt; programming model. Supports management of Dapr building-blocks and configuration.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Applications.Datastores&lt;/strong&gt;: Abstractions for data-stores that can be used within an application.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Applications.Messaging&lt;/strong&gt;: Abstractions for messaging systems that can be used within an application.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bicep.Deployments&lt;/strong&gt;: Functionality for processing Bicep deployments.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;applications-resource-provider&#34;&gt;Applications Resource Provider&lt;/h4&gt;
&lt;p&gt;The &lt;strong&gt;Applications.&lt;/strong&gt;* resource providers implement the bulk of Radius&amp;rsquo; user-facing functionality, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Creating and managing platform resources used to run an application (&lt;em&gt;eg: Kubernetes Deployments and Services&lt;/em&gt;).&lt;/li&gt;
&lt;li&gt;Responding to queries from the CLI (&lt;em&gt;eg: list all applications, show configuration of a container&lt;/em&gt;).&lt;/li&gt;
&lt;li&gt;Storing and retrieving dependency information like connection-strings, hostnames, and passwords.&lt;/li&gt;
&lt;li&gt;Executing recipes to create cloud infrastructure.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All of Radius&amp;rsquo; core concepts are expressed using resources:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Applications&lt;/li&gt;
&lt;li&gt;Environments&lt;/li&gt;
&lt;li&gt;Containers&lt;/li&gt;
&lt;li&gt;Dependency resources (eg: Mongo Database, Dapr State Store)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All of these resources can be manipulated using the CRUDL+ operations that the resource providers provide. Since the functionality is implemented as part of the API any number of tools can have access to this functionality.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Applications.*&lt;/code&gt; resource providers are fully-open source and were created as part of the Radius project. The &lt;code&gt;Applications.Core&lt;/code&gt; and &lt;code&gt;Applications.*&lt;/code&gt; resource providers are written in Go.&lt;/p&gt;
&lt;h4 id=&#34;bicep-deployments-resource-provider&#34;&gt;Bicep Deployments Resource Provider&lt;/h4&gt;
&lt;p&gt;The &lt;strong&gt;Bicep.Deployments&lt;/strong&gt; resource provider implements the functionality for handling Bicep deployments.&lt;/p&gt;
&lt;p&gt;First a Bicep file is compiled to an intermediate representation called ARM-JSON and then the compiled payload is sent to the server to create a &lt;code&gt;Bicep.Deployments/deployments&lt;/code&gt; resource. The deployments resource provider processes the ARM-JSON template to create or update other resources by making HTTP requests to UCP. After the processing is completed, the &lt;code&gt;Bicep.Deployments/deployments&lt;/code&gt; resource is retained for informational purposes.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;🚧🚧🚧 Under construction 🚧🚧🚧&lt;/h4&gt;

    The &lt;code&gt;Bicep.Deployments&lt;/code&gt; resource provider shares some components with the Azure service for processing Bicep and ARM-JSON deployments. The codebase will be fully open-sourced and ownership will be split between the Bicep team and the Radius project. The &lt;code&gt;Bicep.Deployments&lt;/code&gt; resource provider is written in C#.

&lt;/div&gt;

&lt;h3 id=&#34;tools-rad-cli-bicep&#34;&gt;Tools (rad CLI, Bicep)&lt;/h3&gt;
&lt;p&gt;Tools that work with Radius do so though the API. The CRUDL+ operations provided by resource providers are orchestrated by tools to perform tasks like application deployment, or listing cloud resources in use by an application.&lt;/p&gt;
&lt;p&gt;This section will provide an overview of how various tools interact with the Radius APIs.&lt;/p&gt;
&lt;h4 id=&#34;rad-cli&#34;&gt;rad CLI&lt;/h4&gt;
&lt;p&gt;The bulk of rad CLI functionality can be described as &lt;em&gt;management functions&lt;/em&gt; that are serviced using the Read and List operations of the Radius API. A typical interaction like listing applications that have been created will only require one request to the API.&lt;/p&gt;
&lt;h4 id=&#34;bicep&#34;&gt;Bicep&lt;/h4&gt;
&lt;p&gt;Resources (&lt;em&gt;Radius, Azure, AWS, Kubernetes&lt;/em&gt;) can be expressed declaratively within a Bicep file and deployed via &lt;code&gt;rad deploy&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The functionality of &lt;code&gt;rad deploy&lt;/code&gt; to deploy a Bicep file also uses the Radius API. Once the deployment has been sent to the server, the CLI monitors the &lt;code&gt;Bicep.Deployments/deployments&lt;/code&gt; resource to display progress information to the user.&lt;/p&gt;
&lt;h4 id=&#34;terraform&#34;&gt;Terraform&lt;/h4&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;🚧🚧🚧 Under construction 🚧🚧🚧&lt;/h4&gt;

    We have not yet published a Terraform provider for Radius. This section describes the architecture differences to help explain the architecture differences.

&lt;/div&gt;

&lt;p&gt;Processing of Terraform deployments takes place on the client that initiated the operation. The Radius Terraform provider makes requests through the API to Read or Create/Update resources as needed.&lt;/p&gt;
&lt;p&gt;In contrast, processing of Bicep templates takes place on the server-side inside a resource provider. The tasks done by Terraform and Bicep are very similar but each tool has a different architecture.&lt;/p&gt;
&lt;h4 id=&#34;example-tasks-and-data-flows&#34;&gt;Example tasks and data flows&lt;/h4&gt;
&lt;p&gt;This section describes example tasks that can be performed with Radius and how the data flows through the overall system.&lt;/p&gt;
&lt;ul class=&#34;nav nav-tabs&#34; id=&#34;tabs-4&#34; role=&#34;tablist&#34;&gt;&lt;li class=&#34;nav-item&#34;&gt;&lt;a class=&#34;nav-link active&#34;
    id=&#34;tabs-4-list-applications-tab&#34; data-toggle=&#34;tab&#34; href=&#34;#tabs-4-list-applications&#34; role=&#34;tab&#34;
    aria-controls=&#34;tabs-4-list-applications&#34; aria-selected=&#34;true&#34;&gt;
    List applications
  &lt;/a&gt;
  &lt;/li&gt;&lt;li class=&#34;nav-item&#34;&gt;&lt;a class=&#34;nav-link&#34;
    id=&#34;tabs-4-deploy-bicep-file-tab&#34; data-toggle=&#34;tab&#34; href=&#34;#tabs-4-deploy-bicep-file&#34; role=&#34;tab&#34;
    aria-controls=&#34;tabs-4-deploy-bicep-file&#34; aria-selected=&#34;false&#34;&gt;
    Deploy Bicep file
  &lt;/a&gt;
  &lt;/li&gt;&lt;li class=&#34;nav-item&#34;&gt;&lt;a class=&#34;nav-link&#34;
    id=&#34;tabs-4-deploy-terraform-file-tab&#34; data-toggle=&#34;tab&#34; href=&#34;#tabs-4-deploy-terraform-file&#34; role=&#34;tab&#34;
    aria-controls=&#34;tabs-4-deploy-terraform-file&#34; aria-selected=&#34;false&#34;&gt;
    Deploy Terraform file
  &lt;/a&gt;
  &lt;/li&gt;&lt;/ul&gt;


&lt;div class=&#34;tab-content&#34; id=&#34;tabs-4-content&#34;&gt;


&lt;div class=&#34;tab-pane fade show active&#34; id=&#34;tabs-4-list-applications&#34; role=&#34;tabpanel&#34; aria-labelled-by=&#34;tabs-4-list-applications-tab&#34;&gt;
&lt;br /&gt;&lt;p&gt;When listing applications using the &lt;code&gt;rad&lt;/code&gt; CLI:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The client sends an HTTP request to the Radius API requesting the list of applications.&lt;/li&gt;
&lt;li&gt;UCP receives the request for the &lt;code&gt;Applications.Core/applications&lt;/code&gt; List operation and looks up the internal address for the &lt;code&gt;Applications.Core&lt;/code&gt; resource provider.&lt;/li&gt;
&lt;li&gt;UCP proxies the HTTP request to the &lt;code&gt;Applications.Core&lt;/code&gt; resource provider.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;Applications.Core&lt;/code&gt; resource provider handles the request and responds with the list of applications.&lt;/li&gt;
&lt;/ol&gt;
&lt;img src=&#34;flow-list-apps.png&#34; alt=&#34;Diagram of the API flow described above&#34; width=&#34;1000px&#34; &gt;
&lt;/div&gt;

&lt;div class=&#34;tab-pane fade&#34; id=&#34;tabs-4-deploy-bicep-file&#34; role=&#34;tabpanel&#34; aria-labelled-by=&#34;tabs-4-deploy-bicep-file-tab&#34;&gt;
&lt;br /&gt;&lt;p&gt;When using Bicep to author and deploy Radius Applications:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The client compiles the Bicep file to an ARM-JSON template and submits a request for processing as a &lt;code&gt;Bicep.Deployments/deployments&lt;/code&gt; resource.&lt;/li&gt;
&lt;li&gt;UCP receives the request for the &lt;code&gt;Bicep.Deployments/deployments&lt;/code&gt; Create operation and looks up the internal address for the &lt;code&gt;Bicep.Deployments&lt;/code&gt; resource provider.&lt;/li&gt;
&lt;li&gt;UCP proxies the HTTP request to the &lt;code&gt;Bicep.Deployments&lt;/code&gt; resource provider.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;Bicep.Deployments&lt;/code&gt; resource provider processes the ARM-JSON template. For each resource in the template:
a. The &lt;code&gt;Bicep.Deployments&lt;/code&gt; resource provider makes a request to UCP to Create/Update the resource.
b. UCP routes the request to the appropriate resource provider to be handled.&lt;/li&gt;
&lt;/ol&gt;
&lt;img src=&#34;flow-deploy.png&#34; alt=&#34;Diagram of the API flow described above&#34; width=&#34;1000px&#34; &gt;
&lt;/div&gt;

&lt;div class=&#34;tab-pane fade&#34; id=&#34;tabs-4-deploy-terraform-file&#34; role=&#34;tabpanel&#34; aria-labelled-by=&#34;tabs-4-deploy-terraform-file-tab&#34;&gt;
&lt;br /&gt;&lt;p&gt;When using the &lt;code&gt;tf&lt;/code&gt; CLI to deploy a Radius Application using Terraform:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Terraform reads the configuration, loads credentials, parses the file, and instantiates its providers. For each resource in the file:
a. Terraform asks the appropriate provider to Create or Update the resource.
b. In the case of a non-Radius resource, (eg: AWS S3 Bucket) the Terraform provider processes the resource without involving the Radius API.
c. In the case of a Radius resource the Terraform provider makes a request the Radius API to Create/Update a resource.
d. UCP routes the request to the appropriate resource provider to be handled.&lt;/li&gt;
&lt;/ol&gt;
&lt;img src=&#34;flow-terraform.png&#34; alt=&#34;Diagram of the API flow described above&#34; width=&#34;1000px&#34; &gt;
&lt;/div&gt;


&lt;/div&gt;
&lt;h2 id=&#34;next-step&#34;&gt;Next step&lt;/h2&gt;
&lt;p&gt;Now that you have an understanding of the Radius architecture, try Radius out:&lt;/p&gt;









&lt;a class=&#34;btn btn-lg btn-success&#34; href=&#34;https://docs.radapp.io/getting-started/&#34; role=&#34;button&#34;&gt;Get started&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;

      </description>
    </item>
    
  </channel>
</rss>
